/*
 * @brief FreeRTOS examples
 *
 * @note
 * Copyright(C) NXP Semiconductors, 2014
 * All rights reserved.
 *
 * @par
 * Software that is described herein is for illustrative purposes only
 * which provides customers with programming information regarding the
 * LPC products.  This software is supplied "AS IS" without any warranties of
 * any kind, and NXP Semiconductors and its licensor disclaim any and
 * all warranties, express or implied, including all implied warranties of
 * merchantability, fitness for a particular purpose and non-infringement of
 * intellectual property rights.  NXP Semiconductors assumes no responsibility
 * or liability for the use of the software, conveys no license or rights under any
 * patent, copyright, mask work right, or any other intellectual property rights in
 * or to any products. NXP Semiconductors reserves the right to make changes
 * in the software without notification. NXP Semiconductors also makes no
 * representation or warranty that such application will be suitable for the
 * specified use without further testing or modification.
 *
 * @par
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, under NXP Semiconductors' and its
 * licensor's relevant copyrights in the software, without fee, provided that it
 * is used in conjunction with NXP Semiconductors microcontrollers.  This
 * copyright, permission, and disclaimer notice must appear in all copies of
 * this code.
 */

#include "board.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include <stdlib.h>

/****************************************************************************
 * Prototipos de funciones
 ****************************************************************************/
float get_temperature(uint16_t adc_value);	//Funcion que mapea la tension de la termocupla y la temperatura
void SetupHardware(void);				//Configuracion del hardware
void ConfigureADC(void);				//Configuracion del ADC
void ConfigurePhaseDetector(void);	//Configuracion del detector de cruce por cero
void ConfigureTrigger(void);			//Configuracion del timer que dispara el trigger
static void vHandlerZeroCrossing(void *pvParameters);	//Tarea de deteccion de cruce por cero
static void vHandlerController(void *pvParameters);			//Tarea que aplica el controlador
/************************************************************/

/*************************************************************************
 * Variables gloables
 *************************************************************************/
xSemaphoreHandle xPhaseSemaphore;	//Semaforo para la deteccion de cruce por cero
xSemaphoreHandle xControllerSemaphore;		//Semaforo para la ejecucion del controlador

volatile uint16_t adc_data;			//Valor leido en el ADC
uint16_t thermocouple_temp;			//Valor de la temperatura medida con la termocupla (ya promediado)
ADC_CLOCK_SETUP_T ADCSetup;			//Estructura de condiguracion del ADC
#define ADC_INTERRUPT_PRIORITY	5	//Prioridad de la interrupcion del ADC

#define MAX_ADC_SAMPLES 	10			//Cantidad de mediciones que se desean promediar
#define ADC_SAMPLES_DELAY 	(500/portTICK_RATE_MS)	//Delay entre actualizaciones de la temperatura

/* Pin de deteccion de fase */
#define PHASE_SCU_INT_PORT	6			//Puerto del SCU usado para la deteccion de fase
#define PHASE_SCU_INT_PIN	1				//Pin del SCU usado para la deteccion de fase
#define PHASE_GPIO_INT_PORT	3			//Puerto del GPIO usado para la deteccion de fase
#define PHASE_GPIO_INT_PIN	0			//Pin del GPIO usado para la deteccion de fase
#define PHASE_PININT_INDEX	0			//Canal de las interrupciones para el cruce por cero
#define PHASE_INTERRUPT_PRIORITY	5		//Prioridad de la interrupcion del detector de cruce por cero

/* Pin de trigger del triac */
#define TRIGGER_SCU_INT_PORT	6			//Puerto del SCU usado para el trigger del triac
#define TRIGGER_SCU_INT_PIN		5			//Pin del SCU usado para el trigger del triac
#define TRIGGER_GPIO_INT_PORT	3			//Puerto del GPIO usado para el trigger del triac
#define TRIGGER_GPIO_INT_PIN	4			//Pin del GPIO usado para el trigger del triac

/* Variables y constantes para el controlador */
#define OPAMP_GAIN	245.4	//Ganancia del circuito amplificador de la termocupla

const float reference=58;	//Temperatura de referencia para el controladro
bool trigger_state=false;
/*****************************************************************************/

/*****************************************************************************
 * Otras funciones
*****************************************************************************/
/* Uso el Hook de la tarea Idle. De esta forma tomo muestras del ADC siempre que haya
 * un intervalo de tiempo disponible.
 */
void vApplicationIdleHook(void){
	/* Si se alcanzo el valor maximo de semiciclos de la senoidal,
	 * entonces se lee un nuevo valor del ADC.
	 */
	if( cycles_count >= MAX_CYCLES ){
		cycles_count=0;		//Se resetea el contador de ciclos
		Chip_ADC_SetStartMode(LPC_ADC0, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
	}
}

/* Funcion que mapea la temperatura a partir de la tension de la termocupla */
float get_temperature( uint16_t adc_value ){
	float temp=0;

	temp = ((float)adc_value)*3.3/1024;		//Lo mapeo de 0-3.3v
	temp /= OPAMP_GAIN;						//Lo divido por la ganancia del operacional
	temp =23376.525*temp-1.574;				//Mapeo la temperatura
return temp;
}
/*****************************************************************************/

/*****************************************************************************
 * Handlers de interrupciones
*****************************************************************************/
/* Handler del ADC0 */
void ADC0_IRQHandler(void){
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	Chip_ADC_ReadValue(LPC_ADC0, ADC_CH0,&adc_data);	//Se hace una nueva lectura de la temperatura

	xSemaphoreGiveFromISR(xADCSemaphore, &xHigherPriorityTaskWoken);	//Se otorga el semaforo
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);		//Se fuerza un cambio de contexto si es necesario
}

/* Handler de las interrupciones del GPIO */
void GPIO0_IRQHandler(void){
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(PHASE_PININT_INDEX));	//Se limpian las interrupciones

	xSemaphoreGiveFromISR(xPhaseSemaphore, &xHigherPriorityTaskWoken);	//Se otorga el semaforo
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);		//Se fuerza un cambio de contexto si es necesario
}

/******************************************************************************/

/*****************************************************************************
 * Funciones de configuracion
*****************************************************************************/
/* Sets up system hardware */
void SetupHardware(void){
	SystemCoreClockUpdate();
	Board_Init();

	ConfigureADC();	//Configuracion del ADC
	ConfigurePhaseDetector();	//Configuracion de las interrupciones para el detector de fase
	ConfigureTrigger();	//Se configura el timer para la generacion del delay del trigger
}

/* Configuracion del ADC */
void ConfigureADC( void ){
	Chip_ADC_Init(LPC_ADC0, &ADCSetup);						//Se inicializa el ADC
	Chip_ADC_EnableChannel(LPC_ADC0, ADC_CH0, ENABLE);		//Se habilita el canal 0
	NVIC_SetPriority(ADC0_IRQn, ADC_INTERRUPT_PRIORITY);	//Se setea la prioridad de la interrupcion
	NVIC_EnableIRQ(ADC0_IRQn);								//Se habilita las interrupciones
	Chip_ADC_Int_SetChannelCmd(LPC_ADC0, ADC_CH0, ENABLE);	//Se habilita las interrupciones del canal 0
}

/* Configuro las interrupciones externas generadas por el detector de fase.*/
void ConfigurePhaseDetector( void ){

	/* Se configura el pin de deteccion para el modo GPIO */
	Chip_SCU_PinMuxSet(PHASE_SCU_INT_PORT, PHASE_SCU_INT_PIN,(SCU_MODE_INBUFF_EN|SCU_MODE_INACT|SCU_MODE_FUNC0) );

	/* Se configura el pin como entrada */
	Chip_GPIO_SetPinDIRInput(LPC_GPIO_PORT, PHASE_GPIO_INT_PORT, PHASE_GPIO_INT_PIN);

	/* Se configura el canal PININT_INDEX para las interrupciones */
	Chip_SCU_GPIOIntPinSel(PHASE_PININT_INDEX, PHASE_GPIO_INT_PORT, PHASE_GPIO_INT_PIN);

	Chip_PININT_ClearIntStatus(LPC_GPIO_PIN_INT, PININTCH(PHASE_PININT_INDEX));	//Se limpian las interrupciones
	Chip_PININT_SetPinModeEdge(LPC_GPIO_PIN_INT, PININTCH(PHASE_PININT_INDEX));	//Se setea el trigger por flancos
	LPC_GPIO_PIN_INT->SIENR |= PININTCH(PHASE_PININT_INDEX);					//Se setean los flancos ascendentes
	LPC_GPIO_PIN_INT->SIENF |= PININTCH(PHASE_PININT_INDEX);					//Se setean los flancos descendentes

	/* Habilitacion de las interrupciones */
	NVIC_SetPriority(PIN_INT0_IRQn, PHASE_INTERRUPT_PRIORITY);	//Se setea la prioridad de la interrupcion
	NVIC_ClearPendingIRQ(PIN_INT0_IRQn);						//Se limpian las interrupciones pendientes
	NVIC_EnableIRQ(PIN_INT0_IRQn);								//Se habilitan las interrupciones para el pin
}

/* Configuracion del trigger */
void ConfigureTrigger( void ){
	/* Configuracion del pin de trigger del triac */
	Chip_SCU_PinMuxSet(TRIGGER_SCU_INT_PORT, TRIGGER_SCU_INT_PIN,(SCU_MODE_INBUFF_EN|SCU_MODE_INACT|SCU_MODE_FUNC0));
	Chip_GPIO_SetPinDIROutput(LPC_GPIO_PORT, TRIGGER_GPIO_INT_PORT, TRIGGER_GPIO_INT_PIN);	//Pin de salida
	Chip_GPIO_SetPinState(LPC_GPIO_PORT, TRIGGER_GPIO_INT_PORT, TRIGGER_GPIO_INT_PIN, (bool) false);
}

/*****************************************************************************/

/*****************************************************************************
 * Definicion de las tareas
*****************************************************************************/
/* Esta tarea toma muestras de la temperatura y las promedia para reducir el ruido */
static void vHandlerGetTemperature(void *pvParameters){
	uint8_t i=0;	//Cantidad de mediciones realizadas
	uint16_t aux=0;	//Variable auxiliar para almacenar valores del ADC

	while(1){
		Chip_ADC_SetStartMode(LPC_ADC0, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
		/* La tarea permanece bloqueada hasta que el semaforo se libera */
		xSemaphoreTake(xADCSemaphore, portMAX_DELAY);
		i++;	//Se realizo una nueva medicion

		aux+=adc_data;	//Se suma el nuevo valor a los anteriores
		if( i > MAX_ADC_SAMPLES ){
			i=0;
			thermocouple_temp=aux/MAX_ADC_SAMPLES;	//Se guarda el promedio de las temperaturas

			vTaskDelay( ADC_SAMPLES_DELAY );		//Se bloquea la tarea por un cierto tiempo
		}

	}
}
/* Esta tarea se ejecuta siempre que se produzca un cruce por cero.*/
static void vHandlerZeroCrossing(void *pvParameters){

	/* Se toma el semaforo para vaciarlo antes de entrar al loop infinito */
    xSemaphoreTake(xPhaseSemaphore, (portTickType) 0);

	while (1) {

		/* La tarea permanece bloqueada hasta que el semaforo se libera */
        xSemaphoreTake(xPhaseSemaphore, portMAX_DELAY);

        cycles_count++;		//Se cuenta un nuevo ciclo de la senoidal

        /* Se dispara el trigger */
        Chip_GPIO_SetPinState(LPC_GPIO_PORT, TRIGGER_GPIO_INT_PORT, TRIGGER_GPIO_INT_PIN, trigger_state);
    }
}

/* Esta tarea aplica el controlador a las lecturas del ADC .*/
static void vHandlerController(void *pvParameters){

	float temperature;		//Temperatura medida con la termocupla

	/* Se toma el semaforo para vaciarlo antes de entrar al loop infinito */
    xSemaphoreTake(xControllerSemaphore, (portTickType) 0);

	while (1) {

		/* La tarea permanece bloqueada hasta que el semaforo se libera */
        xSemaphoreTake(xControllerSemaphore, portMAX_DELAY);

		temperature = get_temperature( thermocouple_temp );	//Mapeo la temperatura

		if( temperature >= reference )
			trigger_state = FALSE;	//Si la temperatura es mayor, se apaga la potencia
		else
			trigger_state = TRUE;	//Si la temperatura es menor, se mantiene encendida la potencia

    }
}
/*****************************************************************************/


/*****************************************************************************
 * Funcion main
 ****************************************************************************/
int main(void){
	SetupHardware();	//Se inicializa el hardware

	vSemaphoreCreateBinary(xPhaseSemaphore);	//Se crea el semaforo para la deteccion de cruces por cero
	vSemaphoreCreateBinary(xControllerSemaphore);		//Se crea el semaforo para el controlador

	/* Se verifica que el semaforo haya sido creado correctamente */
	if( (xPhaseSemaphore!=(xSemaphoreHandle)NULL)&&(xControllerSemaphore!=(xSemaphoreHandle)NULL) ){

		/* Se crea la tarea que se encarga de detectar los cruces por cero */
		xTaskCreate(vHandlerGetTemperature, (char *) "GetTemperature", configMINIMAL_STACK_SIZE,
							(void *) 0, (tskIDLE_PRIORITY + 1UL), (xTaskHandle *) NULL);
		/* Se crea la tarea que se encarga de detectar los cruces por cero */
		xTaskCreate(vHandlerZeroCrossing, (char *) "ZeroCrossing", configMINIMAL_STACK_SIZE,
							(void *) 0, (tskIDLE_PRIORITY + 2UL), (xTaskHandle *) NULL);
		/* Se crea la tarea que se encarga de aplicar el controlador */
		xTaskCreate(vHandlerController, (char *) "Controller", configMINIMAL_STACK_SIZE,
							(void *) 0, (tskIDLE_PRIORITY + 1UL), (xTaskHandle *) NULL);

		vTaskStartScheduler(); /* Se comienzan a ejecutar las tareas. */
	}
	while (1);	//No se deberia llegar nunca a este punto.
return ((int) NULL);
}
